<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NCTS Syndication</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <h1>NCTS Terminology Syndication</h1>
        <p class="subtitle">Sync and manage Australian clinical terminology standards</p>

        <div class="actions">
            <button id="testConnection" class="test-connection-btn">Test NCTS Connection</button>
            <button id="syncAll">Sync All Terminologies</button>
            <button id="refreshStatus">Refresh Status</button>
            <div id="connectionStatus" class="connection-status hidden"></div>
        </div>

        <div class="search-panel">
            <h2>Search Terminology</h2>
            <div class="search-controls">
                <input type="text" id="searchInput" placeholder="Search for codes or terms (e.g., 'diabetes', '73211009')...">
                <div class="search-filters">
                    <label><input type="checkbox" value="snomed" checked> SNOMED</label>
                    <label><input type="checkbox" value="amt" checked> AMT</label>
                    <label><input type="checkbox" value="valuesets" checked> ValueSets</label>
                    <label><input type="checkbox" value="all"> All</label>
                </div>
                <button id="searchBtn">Search</button>
            </div>
            <div id="searchResults" class="search-results hidden">
                <h3>Results</h3>
                <div class="results-container"></div>
            </div>
        </div>

        <div class="terminology-grid" id="terminologies">
            <!-- Terminology cards will be inserted here -->
        </div>

        <div class="stats-panel" id="statsPanel">
            <h2>Storage Statistics</h2>
            <div class="stats-grid" id="statsGrid">
                <div class="stat-card">
                    <span class="stat-label">Database Size</span>
                    <span class="stat-value" id="statDatabaseSize">-</span>
                </div>
                <div class="stat-card">
                    <span class="stat-label">SNOMED Concepts</span>
                    <span class="stat-value" id="statSnomedConcepts">-</span>
                </div>
                <div class="stat-card">
                    <span class="stat-label">SNOMED Descriptions</span>
                    <span class="stat-value" id="statSnomedDescriptions">-</span>
                </div>
                <div class="stat-card">
                    <span class="stat-label">AMT Codes</span>
                    <span class="stat-value" id="statAmtCodes">-</span>
                </div>
                <div class="stat-card">
                    <span class="stat-label">Value Sets</span>
                    <span class="stat-value" id="statValueSets">-</span>
                </div>
            </div>
        </div>

        <div class="valueset-browser">
            <h2>ValueSet Browser</h2>
            <div class="browser-controls">
                <button id="loadValueSetsBtn">Load All ValueSets</button>
                <input type="text" id="valuesetFilterInput" placeholder="Filter ValueSets by name or URL...">
            </div>
            <div id="valuesetList" class="valueset-list hidden">
                <!-- ValueSets will be loaded here -->
            </div>
            <div id="valuesetExpansion" class="valueset-expansion hidden">
                <div class="expansion-header">
                    <h3 id="expansionTitle">ValueSet Expansion</h3>
                    <button id="closeExpansionBtn">Close</button>
                </div>
                <div id="expansionContent" class="expansion-content">
                    <!-- Expansion will be loaded here -->
                </div>
            </div>
        </div>

        <div class="logs">
            <h2>Activity Log</h2>
            <div id="logEntries"></div>
        </div>
    </div>

    <script>
        const { invoke } = window.__TAURI__.core;

        const terminologies = [
            { id: 'snomed', name: 'SNOMED CT-AU', description: 'Systematized Nomenclature of Medicine - Australian Edition (SNAPSHOT)', available: true },
            { id: 'loinc', name: 'LOINC', description: 'Not available via syndication (proprietary binary format only)', available: false },
            { id: 'amt', name: 'AMT', description: 'Australian Medicines Terminology (CSV format)', available: true },
            { id: 'valuesets', name: 'Value Sets', description: 'NCTS FHIR R4 Bundles', available: true }
        ];

        let statusData = {};

        function log(message, type = 'info') {
            const logEntries = document.getElementById('logEntries');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            logEntries.insertBefore(entry, logEntries.firstChild);

            // Keep only last 20 entries
            while (logEntries.children.length > 20) {
                logEntries.removeChild(logEntries.lastChild);
            }
        }

        let syncProgressListener = null;

        async function syncTerminology(id) {
            const card = document.querySelector(`[data-id="${id}"]`);
            const statusEl = card.querySelector('.status');
            const syncBtn = card.querySelector('.sync-btn');

            statusEl.className = 'status syncing';
            statusEl.innerHTML = '<span class="progress-spinner"></span> Syncing...';
            syncBtn.disabled = true;

            const termName = terminologies.find(t => t.id === id).name;
            log(`Starting sync for ${termName}...`);

            // Listen for sync progress events
            if (syncProgressListener) {
                syncProgressListener();
            }

            syncProgressListener = await window.__TAURI__.event.listen('sync-progress', (event) => {
                const progress = event.payload;
                statusEl.innerHTML = `<span class="progress-spinner"></span> ${progress.phase}: ${progress.message}`;
            });

            try {
                const result = await invoke('sync_terminology', { terminologyType: id });

                // Clean up listener
                if (syncProgressListener) {
                    syncProgressListener();
                    syncProgressListener = null;
                }

                if (result.success) {
                    statusEl.className = 'status synced';
                    statusEl.textContent = 'Synced';
                    log(`✓ ${result.terminology_type} synced successfully: ${result.latest_version}`, 'success');
                } else {
                    statusEl.className = 'status error';
                    statusEl.textContent = 'Error';
                    log(`✗ ${result.terminology_type} sync failed: ${result.error}`, 'error');
                }

                await refreshStatus();
            } catch (error) {
                // Clean up listener
                if (syncProgressListener) {
                    syncProgressListener();
                    syncProgressListener = null;
                }

                statusEl.className = 'status error';
                statusEl.textContent = 'Error';
                log(`✗ Sync failed: ${error}`, 'error');
            } finally {
                syncBtn.disabled = false;
            }
        }

        async function syncAll() {
            const syncBtn = document.getElementById('syncAll');
            syncBtn.disabled = true;
            syncBtn.innerHTML = '<span class="loading"></span> Syncing All...';

            log('Starting sync for all terminologies...');

            try {
                const results = await invoke('sync_all_terminologies');

                for (const result of results) {
                    if (result.success) {
                        log(`✓ ${result.terminology_type}: ${result.latest_version || 'Up to date'}`, 'success');
                    } else {
                        log(`✗ ${result.terminology_type}: ${result.error}`, 'error');
                    }
                }

                await refreshStatus();
            } catch (error) {
                log(`✗ Sync all failed: ${error}`, 'error');
            } finally {
                syncBtn.disabled = false;
                syncBtn.textContent = 'Sync All Terminologies';
            }
        }

        let importProgressListener = null;

        async function importTerminology(id) {
            const card = document.querySelector(`[data-id="${id}"]`);
            const importBtn = card.querySelector('.import-btn');

            if (!importBtn) return;

            const statusBadges = card.querySelector('.status-badges');
            const originalHtml = statusBadges.innerHTML;

            // Define phases for each terminology type
            const phases = {
                'snomed': ['Extracting', 'Locating Files', 'Importing Concepts', 'Importing Descriptions', 'Importing Relationships', 'Cleanup', 'Complete'],
                'amt': ['Importing AMT', 'Complete'],
                'valuesets': ['Importing ValueSets', 'Complete']
            };

            // Create multi-phase progress UI
            const phaseList = phases[id] || ['Import', 'Complete'];
            const progressHtml = `
                <div class="import-progress-multi" id="import-progress-${id}">
                    ${phaseList.map(phase => `
                        <div class="phase-item" data-phase="${phase}">
                            <span class="phase-icon"></span>
                            <span class="phase-label">${phase}</span>
                            <span class="phase-count"></span>
                        </div>
                    `).join('')}
                    <div class="progress-bar-container" style="display: none;">
                        <div class="progress-bar" id="progress-bar-${id}">
                            <span class="progress-percentage"></span>
                        </div>
                    </div>
                </div>
            `;
            statusBadges.innerHTML = progressHtml;
            importBtn.disabled = true;

            const termName = terminologies.find(t => t.id === id).name;
            log(`Starting import for ${termName}... (This may take several minutes)`);

            // Listen for progress events
            if (importProgressListener) {
                importProgressListener();
            }

            importProgressListener = await window.__TAURI__.event.listen('import-progress', (event) => {
                const progress = event.payload;
                const container = document.getElementById(`import-progress-${id}`);

                if (!container) return;

                const progressBarContainer = container.querySelector('.progress-bar-container');
                const progressBar = container.querySelector('.progress-bar');
                const progressPercentage = progressBar?.querySelector('.progress-percentage');

                // Update all phase items based on status
                const phaseItems = container.querySelectorAll('.phase-item');
                phaseItems.forEach(item => {
                    const phaseName = item.getAttribute('data-phase');
                    const icon = item.querySelector('.phase-icon');
                    const countSpan = item.querySelector('.phase-count');

                    if (phaseName === progress.phase) {
                        // Current phase
                        if (progress.phase_status === 'in_progress') {
                            icon.textContent = '✓';
                            item.classList.remove('completed', 'pending');
                            item.classList.add('in-progress');

                            // Show progress bar if we have total count
                            if (progress.total && progressBarContainer && progressBar) {
                                progressBarContainer.style.display = 'block';
                                progressBar.style.width = `${progress.percentage}%`;
                                if (progressPercentage) {
                                    progressPercentage.textContent = `${Math.round(progress.percentage)}%`;
                                }
                                countSpan.textContent = `(${progress.current.toLocaleString()} / ${progress.total.toLocaleString()})`;
                            } else if (progressBarContainer) {
                                progressBarContainer.style.display = 'none';
                                countSpan.textContent = '';
                            }
                        } else if (progress.phase_status === 'completed') {
                            icon.textContent = '✓';
                            item.classList.remove('in-progress', 'pending');
                            item.classList.add('completed');
                            if (progressBarContainer) {
                                progressBarContainer.style.display = 'none';
                            }

                            if (progress.total) {
                                countSpan.textContent = `(${progress.current.toLocaleString()} / ${progress.total.toLocaleString()})`;
                            }
                        }
                    } else {
                        // Check if this phase is before or after the current phase
                        const currentPhaseIndex = Array.from(phaseItems).findIndex(p => p.getAttribute('data-phase') === progress.phase);
                        const thisPhaseIndex = Array.from(phaseItems).indexOf(item);

                        if (thisPhaseIndex < currentPhaseIndex) {
                            // Previous phase - mark as completed
                            if (!item.classList.contains('completed')) {
                                icon.textContent = '✓';
                                item.classList.remove('in-progress', 'pending');
                                item.classList.add('completed');
                            }
                        } else {
                            // Future phase - mark as pending
                            if (!item.classList.contains('completed')) {
                                icon.textContent = '';
                                item.classList.remove('in-progress', 'completed');
                                item.classList.add('pending');
                                countSpan.textContent = '';
                            }
                        }
                    }
                });
            });

            try {
                const result = await invoke('import_terminology', { terminologyType: id });

                log(`✓ ${termName} imported successfully`, 'success');

                // Clean up listener
                if (importProgressListener) {
                    importProgressListener();
                    importProgressListener = null;
                }

                await refreshStatus();
                await refreshStats();
            } catch (error) {
                // Clean up listener
                if (importProgressListener) {
                    importProgressListener();
                    importProgressListener = null;
                }

                statusBadges.innerHTML = originalHtml;
                log(`✗ Import failed: ${error}`, 'error');
                importBtn.disabled = false;
            }
        }

        async function searchTerminology() {
            const input = document.getElementById('searchInput');
            const query = input.value.trim();

            if (!query || query.length < 2) {
                log('Please enter at least 2 characters to search', 'error');
                return;
            }

            const checkboxes = document.querySelectorAll('.search-filters input[type="checkbox"]:checked');
            const terminologyTypes = Array.from(checkboxes).map(cb => cb.value);

            if (terminologyTypes.length === 0) {
                log('Please select at least one terminology type', 'error');
                return;
            }

            log(`Searching for "${query}" in ${terminologyTypes.join(', ')}...`);

            try {
                const results = await invoke('search_terminology', {
                    query,
                    terminologyTypes,
                    limit: 50
                });

                displaySearchResults(results);
            } catch (error) {
                log(`✗ Search failed: ${error}`, 'error');
            }
        }

        function displaySearchResults(results) {
            const resultsSection = document.getElementById('searchResults');
            const container = resultsSection.querySelector('.results-container');

            if (results.length === 0) {
                container.innerHTML = '<p class="no-results">No results found</p>';
                resultsSection.classList.remove('hidden');
                return;
            }

            const tableHtml = `
                <table class="results-table">
                    <thead>
                        <tr>
                            <th>Code</th>
                            <th>System</th>
                            <th>Display</th>
                            <th>Type</th>
                            <th>Subtype</th>
                            <th>Status</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${results.map(r => `
                            <tr>
                                <td><code>${r.code}</code></td>
                                <td>${r.system.split('/').pop()}</td>
                                <td>${r.display}</td>
                                <td>${r.terminology_type.toUpperCase()}</td>
                                <td>${r.subtype || '-'}</td>
                                <td><span class="status-pill ${r.active ? 'active' : 'inactive'}">${r.active ? 'Active' : 'Inactive'}</span></td>
                                <td>
                                    ${r.terminology_type === 'valuesets'
                                        ? `<button class="expand-btn-small" data-url="${r.code}">Expand</button>`
                                        : '-'}
                                </td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
                <p class="results-count">Showing ${results.length} results</p>
            `;

            container.innerHTML = tableHtml;
            resultsSection.classList.remove('hidden');

            // Add event listeners to expand buttons
            container.querySelectorAll('.expand-btn-small').forEach(btn => {
                btn.addEventListener('click', () => {
                    const url = btn.getAttribute('data-url');
                    expandValueSet(url);
                });
            });

            log(`Found ${results.length} results`, 'success');
        }

        async function refreshStats() {
            try {
                const stats = await invoke('get_storage_stats');

                document.getElementById('statDatabaseSize').textContent = stats.database_size_mb.toFixed(1) + ' MB';
                document.getElementById('statSnomedConcepts').textContent = stats.snomed_concepts.toLocaleString();
                document.getElementById('statSnomedDescriptions').textContent = stats.snomed_descriptions.toLocaleString();
                document.getElementById('statAmtCodes').textContent = stats.amt_codes.toLocaleString();
                document.getElementById('statValueSets').textContent = stats.valuesets.toLocaleString();
            } catch (error) {
                console.error('Failed to refresh stats:', error);
            }
        }

        let allValueSets = [];

        async function loadValueSets() {
            const btn = document.getElementById('loadValueSetsBtn');
            btn.disabled = true;
            btn.textContent = 'Loading...';

            try {
                const valuesets = await invoke('list_valuesets');
                allValueSets = valuesets;

                renderValueSetList(valuesets);
                document.getElementById('valuesetList').classList.remove('hidden');

                log(`Loaded ${valuesets.length} ValueSets`, 'success');
            } catch (error) {
                log(`✗ Failed to load ValueSets: ${error}`, 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = 'Reload ValueSets';
            }
        }

        function renderValueSetList(valuesets) {
            const container = document.getElementById('valuesetList');

            if (valuesets.length === 0) {
                container.innerHTML = '<p class="no-results">No ValueSets available. Import ValueSets terminology first.</p>';
                return;
            }

            const html = `
                <table class="valueset-table">
                    <thead>
                        <tr>
                            <th>Title</th>
                            <th>URL</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${valuesets.map(([url, title]) => `
                            <tr>
                                <td>${title || url.split('/').pop()}</td>
                                <td><code class="valueset-url">${url}</code></td>
                                <td><button class="expand-btn" data-url="${url}">Expand</button></td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;

            container.innerHTML = html;

            // Add event listeners to expand buttons
            container.querySelectorAll('.expand-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const url = btn.getAttribute('data-url');
                    expandValueSet(url);
                });
            });
        }

        async function expandValueSet(url) {
            const expansionDiv = document.getElementById('valuesetExpansion');
            const titleEl = document.getElementById('expansionTitle');
            const contentEl = document.getElementById('expansionContent');

            titleEl.textContent = 'Loading...';
            contentEl.innerHTML = '<p class="loading-text">Expanding ValueSet...</p>';
            expansionDiv.classList.remove('hidden');

            log(`Expanding ValueSet: ${url}`);

            try {
                const expansion = await invoke('expand_valueset', { valuesetUrl: url });

                if (!expansion) {
                    contentEl.innerHTML = '<p class="no-results">ValueSet not found or has no expansion.</p>';
                    titleEl.textContent = 'Not Found';
                    return;
                }

                titleEl.textContent = expansion.title || url.split('/').pop();

                const html = `
                    <div class="expansion-meta">
                        <div class="meta-row">
                            <span class="meta-label">URL:</span>
                            <span class="meta-value"><code>${expansion.url}</code></span>
                        </div>
                        ${expansion.version ? `
                        <div class="meta-row">
                            <span class="meta-label">Version:</span>
                            <span class="meta-value">${expansion.version}</span>
                        </div>
                        ` : ''}
                        <div class="meta-row">
                            <span class="meta-label">Total Concepts:</span>
                            <span class="meta-value">${expansion.total}</span>
                        </div>
                    </div>
                    <table class="expansion-table">
                        <thead>
                            <tr>
                                <th>Code</th>
                                <th>System</th>
                                <th>Display</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${expansion.concepts.map(c => `
                                <tr>
                                    <td><code>${c.code}</code></td>
                                    <td>${c.system.split('/').pop()}</td>
                                    <td>${c.display || '-'}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;

                contentEl.innerHTML = html;
                log(`✓ Expanded ValueSet with ${expansion.total} concepts`, 'success');
            } catch (error) {
                contentEl.innerHTML = `<p class="error-text">Failed to expand: ${error}</p>`;
                log(`✗ Failed to expand ValueSet: ${error}`, 'error');
            }
        }

        function filterValueSets() {
            const input = document.getElementById('valuesetFilterInput');
            const filter = input.value.toLowerCase();

            if (!filter) {
                renderValueSetList(allValueSets);
                return;
            }

            const filtered = allValueSets.filter(([url, title]) => {
                return url.toLowerCase().includes(filter) || (title && title.toLowerCase().includes(filter));
            });

            renderValueSetList(filtered);
        }

        async function refreshStatus() {
            try {
                const allLatest = await invoke('get_all_local_latest');

                statusData = {};
                for (const version of allLatest) {
                    statusData[version.terminology_type] = version;
                }

                renderTerminologies();
            } catch (error) {
                log(`Failed to refresh status: ${error}`, 'error');
            }
        }

        function renderTerminologies() {
            const container = document.getElementById('terminologies');
            container.innerHTML = '';

            for (const term of terminologies) {
                const status = statusData[term.id];
                const card = document.createElement('div');
                card.className = 'terminology-card';
                card.setAttribute('data-id', term.id);

                // Handle unavailable terminologies
                if (!term.available) {
                    card.innerHTML = `
                        <h3>${term.name}</h3>
                        <span class="status not-synced">Not Available</span>
                        <p class="description">${term.description}</p>
                        <div class="card-actions">
                            <button class="sync-btn" disabled>
                                Not Available
                            </button>
                        </div>
                    `;
                    container.appendChild(card);
                    continue;
                }

                // Determine status badges
                const downloaded = status && status.downloaded_at;
                const imported = status && status.imported;

                let statusBadges = '';
                if (downloaded) {
                    statusBadges += '<span class="status synced">Downloaded</span>';
                }
                if (imported) {
                    statusBadges += '<span class="status imported">Imported</span>';
                }
                if (!downloaded) {
                    statusBadges = '<span class="status not-synced">Not Synced</span>';
                }

                card.innerHTML = `
                    <h3>${term.name}</h3>
                    <div class="status-badges">${statusBadges}</div>
                    <p class="description">${term.description}</p>
                    ${status ? `
                        <div class="info-row">
                            <span class="info-label">Version:</span>
                            <span class="info-value">${status.version}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Downloaded:</span>
                            <span class="info-value">${status.downloaded_at ? new Date(status.downloaded_at).toLocaleDateString() : 'No'}</span>
                        </div>
                        ${status.imported && status.imported_at ? `
                        <div class="info-row">
                            <span class="info-label">Imported:</span>
                            <span class="info-value">${new Date(status.imported_at).toLocaleDateString()}</span>
                        </div>
                        ` : ''}
                        ${status.effective_date ? `
                        <div class="info-row">
                            <span class="info-label">Effective Date:</span>
                            <span class="info-value">${status.effective_date}</span>
                        </div>
                        ` : ''}
                    ` : '<p class="no-version">No local version available</p>'}
                    <div class="card-actions">
                        <button class="sync-btn" data-term-id="${term.id}">
                            Sync Latest
                        </button>
                        ${downloaded && !imported ? `
                        <button class="import-btn" data-term-id="${term.id}">
                            Import Data
                        </button>
                        ` : ''}
                    </div>
                `;

                container.appendChild(card);
            }

            // Add event listeners to sync buttons
            const syncButtons = document.querySelectorAll('.sync-btn[data-term-id]');
            syncButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const termId = button.getAttribute('data-term-id');
                    syncTerminology(termId);
                });
            });

            // Add event listeners to import buttons
            const importButtons = document.querySelectorAll('.import-btn[data-term-id]');
            importButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const termId = button.getAttribute('data-term-id');
                    importTerminology(termId);
                });
            });
        }

        async function testConnection() {
            const btn = document.getElementById('testConnection');
            const statusDiv = document.getElementById('connectionStatus');

            btn.disabled = true;
            btn.textContent = 'Testing...';
            statusDiv.classList.add('hidden');

            try {
                const status = await invoke('test_connection');

                statusDiv.className = status.connected ? 'connection-status success' : 'connection-status error';
                statusDiv.innerHTML = `
                    <strong>${status.connected ? '✓ Connected' : '✗ Connection Failed'}</strong>
                    <p>${status.message}</p>
                    ${!status.connected ? `
                        <ul class="error-details">
                            <li>Authentication: ${status.auth_ok ? '✓ OK' : '✗ Failed'}</li>
                            <li>Feed Access: ${status.feed_ok ? '✓ OK' : '✗ Failed'}</li>
                        </ul>
                        <p class="error-hint">
                            ${!status.auth_ok ? 'Check your NCTS_CLIENT_ID and NCTS_CLIENT_SECRET in .env file' : 'NCTS API may be temporarily unavailable'}
                        </p>
                    ` : ''}
                `;
                statusDiv.classList.remove('hidden');

                log(status.connected ? '✓ NCTS connection successful' : `✗ Connection failed: ${status.message}`,
                    status.connected ? 'success' : 'error');
            } catch (error) {
                statusDiv.className = 'connection-status error';
                statusDiv.innerHTML = `
                    <strong>✗ Connection Test Failed</strong>
                    <p>${error}</p>
                    <p class="error-hint">Ensure you have NCTS credentials configured in your .env file</p>
                `;
                statusDiv.classList.remove('hidden');
                log(`✗ Connection test error: ${error}`, 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = 'Test NCTS Connection';
            }
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', async () => {
            log('Application started');

            // Add event listeners to top-level buttons
            document.getElementById('testConnection').addEventListener('click', testConnection);
            document.getElementById('syncAll').addEventListener('click', syncAll);
            document.getElementById('refreshStatus').addEventListener('click', refreshStatus);
            document.getElementById('searchBtn').addEventListener('click', searchTerminology);

            // ValueSet browser event listeners
            document.getElementById('loadValueSetsBtn').addEventListener('click', loadValueSets);
            document.getElementById('valuesetFilterInput').addEventListener('input', filterValueSets);
            document.getElementById('closeExpansionBtn').addEventListener('click', () => {
                document.getElementById('valuesetExpansion').classList.add('hidden');
            });

            // Allow search on Enter key
            document.getElementById('searchInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    searchTerminology();
                }
            });

            await refreshStatus();
            await refreshStats();
        });
    </script>
</body>
</html>
