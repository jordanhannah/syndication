<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NCTS Syndication</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <h1>NCTS Terminology Syndication</h1>
        <p class="subtitle">Sync and manage Australian clinical terminology standards</p>

        <div class="actions">
            <button id="testConnection" class="test-connection-btn">Test NCTS Connection</button>
            <button id="syncAll">Sync All Terminologies</button>
            <button id="refreshStatus">Refresh Status</button>
            <button id="cleanupGhosts" title="Clean up ghost version records (versions with timestamps but no files)">Cleanup Database</button>
            <div id="connectionStatus" class="connection-status hidden"></div>
        </div>

        <div class="search-panel">
            <h2>Search Terminology</h2>
            <div class="search-controls">
                <input type="text" id="searchInput" placeholder="Search for codes or terms (e.g., 'diabetes', '73211009')...">
                <div class="search-filters">
                    <label><input type="checkbox" value="snomed" checked> SNOMED</label>
                    <label><input type="checkbox" value="amt" checked> AMT</label>
                    <label><input type="checkbox" value="valuesets" checked> ValueSets</label>
                    <label><input type="checkbox" value="all"> All</label>
                </div>
                <div class="amt-mode-selector">
                    <label class="mode-label">AMT Search Mode:</label>
                    <label class="radio-label">
                        <input type="radio" name="amtMode" value="patient" checked>
                        Patient (MP/TP only)
                    </label>
                    <label class="radio-label">
                        <input type="radio" name="amtMode" value="doctor">
                        Doctor (All codes)
                    </label>
                    <button id="showAmtStatsBtn" class="stats-btn" title="Show AMT code type statistics">üìä Stats</button>
                </div>
                <button id="searchBtn">Search</button>
            </div>
            <div id="amtStatsModal" class="modal hidden">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>AMT Code Type Statistics</h3>
                        <button class="close-modal">&times;</button>
                    </div>
                    <div id="amtStatsContent" class="modal-body">
                        Loading...
                    </div>
                </div>
            </div>
            <div id="searchResults" class="search-results hidden">
                <h3>Results</h3>
                <div class="results-container"></div>
            </div>
        </div>

        <div class="terminology-grid" id="terminologies">
            <!-- Terminology cards will be inserted here -->
        </div>

        <div class="storage-panel" id="storagePanel">
            <h2>Storage Management</h2>
            <div class="storage-summary">
                <div class="summary-item">
                    <span class="summary-label">Total Files:</span>
                    <span class="summary-value" id="summaryTotalFiles">-</span>
                </div>
                <div class="summary-item">
                    <span class="summary-label">Total Database:</span>
                    <span class="summary-value" id="summaryTotalDb">-</span>
                </div>
                <div class="summary-item">
                    <span class="summary-label">Total Storage:</span>
                    <span class="summary-value" id="summaryTotal">-</span>
                </div>
            </div>
            <table class="storage-table" id="storageTable">
                <thead>
                    <tr>
                        <th>Terminology</th>
                        <th>Downloaded File</th>
                        <th>Database</th>
                        <th>Records</th>
                        <th>Total</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="storageTableBody">
                    <tr><td colspan="6" class="loading-text">Loading storage info...</td></tr>
                </tbody>
            </table>
        </div>

        <div class="valueset-browser">
            <h2>ValueSet Browser</h2>
            <div class="browser-controls">
                <button id="loadValueSetsBtn">Load All ValueSets</button>
                <input type="text" id="valuesetFilterInput" placeholder="Filter ValueSets by name or URL...">
            </div>
            <div id="valuesetList" class="valueset-list hidden">
                <!-- ValueSets will be loaded here -->
            </div>
            <div id="valuesetExpansion" class="valueset-expansion hidden">
                <div class="expansion-header">
                    <h3 id="expansionTitle">ValueSet Expansion</h3>
                    <button id="closeExpansionBtn">Close</button>
                </div>
                <div id="expansionContent" class="expansion-content">
                    <!-- Expansion will be loaded here -->
                </div>
            </div>
        </div>

        <div class="logs">
            <h2>Activity Log</h2>
            <div id="logEntries"></div>
        </div>
    </div>

    <!-- Custom Confirmation Modal -->
    <div id="confirmModal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modalTitle">Confirm Action</h3>
            </div>
            <div class="modal-body">
                <p id="modalMessage"></p>
            </div>
            <div class="modal-footer">
                <button id="modalCancel" class="modal-btn modal-btn-cancel">Cancel</button>
                <button id="modalConfirm" class="modal-btn modal-btn-confirm">Confirm</button>
            </div>
        </div>
    </div>

    <script>
        const { invoke } = window.__TAURI__.core;

        const terminologies = [
            { id: 'snomed', name: 'SNOMED CT-AU', description: 'Systematized Nomenclature of Medicine - Australian Edition (SNAPSHOT)', available: true },
            { id: 'loinc', name: 'LOINC', description: 'Not available via syndication (proprietary binary format only)', available: false },
            { id: 'amt', name: 'AMT', description: 'Australian Medicines Terminology (CSV format)', available: true },
            { id: 'valuesets', name: 'Value Sets', description: 'NCTS FHIR R4 Bundles', available: true }
        ];

        let statusData = {};

        // Custom confirmation dialog function
        function showConfirmDialog(title, message) {
            return new Promise((resolve) => {
                const modal = document.getElementById('confirmModal');
                const modalTitle = document.getElementById('modalTitle');
                const modalMessage = document.getElementById('modalMessage');
                const confirmBtn = document.getElementById('modalConfirm');
                const cancelBtn = document.getElementById('modalCancel');

                modalTitle.textContent = title;
                modalMessage.textContent = message;
                modal.classList.remove('hidden');

                function cleanup() {
                    modal.classList.add('hidden');
                    confirmBtn.removeEventListener('click', onConfirm);
                    cancelBtn.removeEventListener('click', onCancel);
                }

                function onConfirm() {
                    cleanup();
                    resolve(true);
                }

                function onCancel() {
                    cleanup();
                    resolve(false);
                }

                confirmBtn.addEventListener('click', onConfirm);
                cancelBtn.addEventListener('click', onCancel);
            });
        }

        function log(message, type = 'info') {
            const logEntries = document.getElementById('logEntries');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            logEntries.insertBefore(entry, logEntries.firstChild);

            // Keep only last 20 entries
            while (logEntries.children.length > 20) {
                logEntries.removeChild(logEntries.lastChild);
            }
        }

        let syncProgressListener = null;

        async function syncTerminology(id) {
            const card = document.querySelector(`[data-id="${id}"]`);
            const statusEl = card.querySelector('.status');
            const syncBtn = card.querySelector('.sync-btn');

            statusEl.className = 'status syncing';
            statusEl.innerHTML = '<span class="progress-spinner"></span> Syncing...';
            syncBtn.disabled = true;

            const termName = terminologies.find(t => t.id === id).name;
            log(`Starting sync for ${termName}...`);

            // Listen for sync progress events
            if (syncProgressListener) {
                syncProgressListener();
            }

            syncProgressListener = await window.__TAURI__.event.listen('sync-progress', (event) => {
                const progress = event.payload;
                statusEl.innerHTML = `<span class="progress-spinner"></span> ${progress.phase}: ${progress.message}`;
            });

            try {
                const result = await invoke('sync_terminology', { terminologyType: id });

                // Clean up listener
                if (syncProgressListener) {
                    syncProgressListener();
                    syncProgressListener = null;
                }

                if (result.success) {
                    statusEl.className = 'status synced';
                    statusEl.textContent = 'Synced';
                    log(`‚úì ${result.terminology_type} synced successfully: ${result.latest_version}`, 'success');
                } else {
                    statusEl.className = 'status error';
                    statusEl.textContent = 'Error';
                    log(`‚úó ${result.terminology_type} sync failed: ${result.error}`, 'error');
                }

                await refreshStatus();
            } catch (error) {
                // Clean up listener
                if (syncProgressListener) {
                    syncProgressListener();
                    syncProgressListener = null;
                }

                statusEl.className = 'status error';
                statusEl.textContent = 'Error';
                log(`‚úó Sync failed: ${error}`, 'error');
            } finally {
                syncBtn.disabled = false;
            }
        }

        async function syncAll() {
            const syncBtn = document.getElementById('syncAll');
            syncBtn.disabled = true;
            syncBtn.innerHTML = '<span class="loading"></span> Syncing All...';

            log('Starting sync for all terminologies...');

            try {
                const results = await invoke('sync_all_terminologies');

                for (const result of results) {
                    if (result.success) {
                        log(`‚úì ${result.terminology_type}: ${result.latest_version || 'Up to date'}`, 'success');
                    } else {
                        log(`‚úó ${result.terminology_type}: ${result.error}`, 'error');
                    }
                }

                await refreshStatus();
            } catch (error) {
                log(`‚úó Sync all failed: ${error}`, 'error');
            } finally {
                syncBtn.disabled = false;
                syncBtn.textContent = 'Sync All Terminologies';
            }
        }

        let importProgressListener = null;

        async function importTerminology(id) {
            const card = document.querySelector(`[data-id="${id}"]`);
            const importBtn = card.querySelector('.import-btn');

            if (!importBtn) return;

            const statusBadges = card.querySelector('.status-badges');
            const originalHtml = statusBadges.innerHTML;

            // Define phases for each terminology type
            const phases = {
                'snomed': ['Extracting', 'Locating Files', 'Importing Concepts', 'Importing Descriptions', 'Importing Relationships', 'Cleanup', 'Complete'],
                'amt': ['Importing AMT', 'Complete'],
                'valuesets': ['Importing ValueSets', 'Complete']
            };

            // Create multi-phase progress UI
            const phaseList = phases[id] || ['Import', 'Complete'];
            const progressHtml = `
                <div class="import-progress-multi" id="import-progress-${id}">
                    ${phaseList.map(phase => `
                        <div class="phase-item" data-phase="${phase}">
                            <span class="phase-icon"></span>
                            <span class="phase-label">${phase}</span>
                            <span class="phase-count"></span>
                        </div>
                    `).join('')}
                    <div class="progress-bar-container" style="display: none;">
                        <div class="progress-bar" id="progress-bar-${id}">
                            <span class="progress-percentage"></span>
                        </div>
                    </div>
                </div>
            `;
            statusBadges.innerHTML = progressHtml;
            importBtn.disabled = true;

            const termName = terminologies.find(t => t.id === id).name;
            log(`Starting import for ${termName}... (This may take several minutes)`);

            // Listen for progress events
            if (importProgressListener) {
                importProgressListener();
            }

            importProgressListener = await window.__TAURI__.event.listen('import-progress', (event) => {
                const progress = event.payload;
                const container = document.getElementById(`import-progress-${id}`);

                if (!container) return;

                const progressBarContainer = container.querySelector('.progress-bar-container');
                const progressBar = container.querySelector('.progress-bar');
                const progressPercentage = progressBar?.querySelector('.progress-percentage');

                // Update all phase items based on status
                const phaseItems = container.querySelectorAll('.phase-item');
                phaseItems.forEach(item => {
                    const phaseName = item.getAttribute('data-phase');
                    const icon = item.querySelector('.phase-icon');
                    const countSpan = item.querySelector('.phase-count');

                    if (phaseName === progress.phase) {
                        // Current phase
                        if (progress.phase_status === 'in_progress') {
                            icon.textContent = '‚úì';
                            item.classList.remove('completed', 'pending');
                            item.classList.add('in-progress');

                            // Show progress bar if we have total count
                            if (progress.total && progressBarContainer && progressBar) {
                                progressBarContainer.style.display = 'block';
                                progressBar.style.width = `${progress.percentage}%`;
                                if (progressPercentage) {
                                    progressPercentage.textContent = `${Math.round(progress.percentage)}%`;
                                }
                                countSpan.textContent = `(${progress.current.toLocaleString()} / ${progress.total.toLocaleString()})`;
                            } else if (progressBarContainer) {
                                progressBarContainer.style.display = 'none';
                                countSpan.textContent = '';
                            }
                        } else if (progress.phase_status === 'completed') {
                            icon.textContent = '‚úì';
                            item.classList.remove('in-progress', 'pending');
                            item.classList.add('completed');
                            if (progressBarContainer) {
                                progressBarContainer.style.display = 'none';
                            }

                            if (progress.total) {
                                countSpan.textContent = `(${progress.current.toLocaleString()} / ${progress.total.toLocaleString()})`;
                            }
                        }
                    } else {
                        // Check if this phase is before or after the current phase
                        const currentPhaseIndex = Array.from(phaseItems).findIndex(p => p.getAttribute('data-phase') === progress.phase);
                        const thisPhaseIndex = Array.from(phaseItems).indexOf(item);

                        if (thisPhaseIndex < currentPhaseIndex) {
                            // Previous phase - mark as completed
                            if (!item.classList.contains('completed')) {
                                icon.textContent = '‚úì';
                                item.classList.remove('in-progress', 'pending');
                                item.classList.add('completed');
                            }
                        } else {
                            // Future phase - mark as pending
                            if (!item.classList.contains('completed')) {
                                icon.textContent = '';
                                item.classList.remove('in-progress', 'completed');
                                item.classList.add('pending');
                                countSpan.textContent = '';
                            }
                        }
                    }
                });
            });

            try {
                const result = await invoke('import_terminology', { terminologyType: id });

                log(`‚úì ${termName} imported successfully`, 'success');

                // Clean up listener
                if (importProgressListener) {
                    importProgressListener();
                    importProgressListener = null;
                }

                await refreshStatus();
                await refreshStorageInfo();
            } catch (error) {
                // Clean up listener
                if (importProgressListener) {
                    importProgressListener();
                    importProgressListener = null;
                }

                statusBadges.innerHTML = originalHtml;
                log(`‚úó Import failed: ${error}`, 'error');
                importBtn.disabled = false;
            }
        }

        async function searchTerminology() {
            const input = document.getElementById('searchInput');
            const query = input.value.trim();

            if (!query || query.length < 2) {
                log('Please enter at least 2 characters to search', 'error');
                return;
            }

            const checkboxes = document.querySelectorAll('.search-filters input[type="checkbox"]:checked');
            const terminologyTypes = Array.from(checkboxes).map(cb => cb.value);

            if (terminologyTypes.length === 0) {
                log('Please select at least one terminology type', 'error');
                return;
            }

            // Check if AMT is selected and use appropriate search mode
            const amtMode = document.querySelector('input[name="amtMode"]:checked')?.value || 'patient';
            const isAmtOnly = terminologyTypes.length === 1 && terminologyTypes[0] === 'amt';

            log(`Searching for "${query}" in ${terminologyTypes.join(', ')}... (AMT mode: ${amtMode})`);

            try {
                let results;

                // Use specialized AMT search if only AMT is selected
                if (isAmtOnly) {
                    if (amtMode === 'patient') {
                        results = await invoke('search_amt_patient', {
                            query,
                            limit: 50
                        });
                        log(`‚úì Found ${results.length} results (Patient mode: MP/TP codes only)`);
                    } else {
                        results = await invoke('search_amt_doctor', {
                            query,
                            limit: 50
                        });
                        log(`‚úì Found ${results.length} results (Doctor mode: all code types)`);
                    }
                } else {
                    // Use general search for mixed terminologies
                    results = await invoke('search_terminology', {
                        query,
                        terminologyTypes,
                        limit: 50
                    });

                    // Note: General search doesn't apply AMT filtering yet
                    if (terminologyTypes.includes('amt')) {
                        log(`Note: AMT mode (${amtMode}) only applies when searching AMT exclusively`);
                    }
                }

                displaySearchResults(results);
            } catch (error) {
                log(`‚úó Search failed: ${error}`, 'error');
            }
        }

        function displaySearchResults(results) {
            const resultsSection = document.getElementById('searchResults');
            const container = resultsSection.querySelector('.results-container');

            if (results.length === 0) {
                container.innerHTML = '<p class="no-results">No results found</p>';
                resultsSection.classList.remove('hidden');
                return;
            }

            const tableHtml = `
                <table class="results-table">
                    <thead>
                        <tr>
                            <th>Code</th>
                            <th>System</th>
                            <th>Display</th>
                            <th>Type</th>
                            <th>Subtype</th>
                            <th>Status</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${results.map(r => `
                            <tr>
                                <td><code>${r.code}</code></td>
                                <td>${r.system.split('/').pop()}</td>
                                <td>${r.display}</td>
                                <td>${r.terminology_type.toUpperCase()}</td>
                                <td>${r.subtype || '-'}</td>
                                <td><span class="status-pill ${r.active ? 'active' : 'inactive'}">${r.active ? 'Active' : 'Inactive'}</span></td>
                                <td>
                                    ${r.terminology_type === 'valuesets'
                                        ? `<button class="expand-btn-small" data-url="${r.code}">Expand</button>`
                                        : '-'}
                                </td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
                <p class="results-count">Showing ${results.length} results</p>
            `;

            container.innerHTML = tableHtml;
            resultsSection.classList.remove('hidden');

            // Add event listeners to expand buttons
            container.querySelectorAll('.expand-btn-small').forEach(btn => {
                btn.addEventListener('click', () => {
                    const url = btn.getAttribute('data-url');
                    expandValueSet(url);
                });
            });

            log(`Found ${results.length} results`, 'success');
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return (bytes / Math.pow(k, i)).toFixed(2) + ' ' + sizes[i];
        }

        function getTerminologyDisplayName(type) {
            const names = {
                'snomed': 'SNOMED CT-AU',
                'amt': 'AMT',
                'valuesets': 'Value Sets'
            };
            return names[type] || type;
        }

        async function refreshStorageInfo() {
            try {
                const breakdown = await invoke('get_detailed_storage_info');

                // Update summary
                document.getElementById('summaryTotalFiles').textContent = formatBytes(breakdown.total_file_size_bytes);
                document.getElementById('summaryTotalDb').textContent = formatBytes(breakdown.total_database_size_bytes);
                document.getElementById('summaryTotal').textContent = formatBytes(breakdown.total_size_bytes);

                // Build table rows
                const tbody = document.getElementById('storageTableBody');
                tbody.innerHTML = '';

                for (const term of breakdown.terminologies) {
                    const row = document.createElement('tr');

                    const fileStatus = term.has_file
                        ? `<span class="status-badge has-data">${formatBytes(term.file_size_bytes)}</span>`
                        : `<span class="status-badge no-data">Not downloaded</span>`;

                    const dbStatus = term.has_database_data
                        ? `<span class="status-badge has-data">${formatBytes(term.database_size_estimate_bytes)}</span>`
                        : `<span class="status-badge no-data">Not imported</span>`;

                    row.innerHTML = `
                        <td><strong>${getTerminologyDisplayName(term.terminology_type)}</strong></td>
                        <td>${fileStatus}</td>
                        <td>${dbStatus}</td>
                        <td>${term.database_records.toLocaleString()}</td>
                        <td><strong>${formatBytes(term.total_size_bytes)}</strong></td>
                        <td class="storage-actions">
                            ${term.has_file ? `
                                <button class="delete-btn delete-file"
                                        data-type="${term.terminology_type}"
                                        title="Delete downloaded file">
                                    üóëÔ∏è File
                                </button>
                            ` : ''}
                            ${term.has_database_data ? `
                                <button class="delete-btn delete-data"
                                        data-type="${term.terminology_type}"
                                        title="Delete database records">
                                    üóëÔ∏è Data
                                </button>
                            ` : ''}
                            ${term.has_file || term.has_database_data ? `
                                <button class="delete-btn delete-all"
                                        data-type="${term.terminology_type}"
                                        title="Delete everything">
                                    üóëÔ∏è All
                                </button>
                            ` : ''}
                        </td>
                    `;

                    tbody.appendChild(row);
                }

            } catch (error) {
                console.error('Failed to refresh storage info:', error);
                log('Failed to refresh storage info: ' + error, 'error');
            }
        }

        async function deleteFile(terminologyType) {
            console.log('deleteFile called with:', terminologyType);
            const termName = getTerminologyDisplayName(terminologyType);
            console.log('Term name:', termName);

            const confirmed = await showConfirmDialog(
                'Confirm File Deletion',
                `Delete downloaded file for ${termName}?\n\nThis will free up disk space but keep the imported database records. You can re-download the file later if needed.`
            );

            if (!confirmed) {
                console.log('User cancelled deletion');
                return;
            }
            console.log('User confirmed deletion, proceeding...');

            try {
                const result = await invoke('delete_terminology_file', { terminologyType });
                log(`‚úì ${result}`, 'success');
                await refreshStorageInfo();
                await refreshStatus();
            } catch (error) {
                log(`‚úó Failed to delete file: ${error}`, 'error');
            }
        }

        let deleteProgressListener = null;

        async function deleteData(terminologyType) {
            console.log('deleteData called with:', terminologyType);
            const termName = getTerminologyDisplayName(terminologyType);

            const confirmed = await showConfirmDialog(
                'Confirm Data Deletion',
                `Delete database records for ${termName}?\n\nThis will remove all imported terminology data. The downloaded file will be kept. You'll need to re-import to use search and lookup features.`
            );

            if (!confirmed) {
                console.log('User cancelled deletion');
                return;
            }
            console.log('User confirmed deletion, proceeding...');

            // Find the row in the storage table
            const tbody = document.getElementById('storageTableBody');
            const rows = tbody.querySelectorAll('tr');
            let targetRow = null;

            rows.forEach(row => {
                const deleteBtn = row.querySelector(`[data-type="${terminologyType}"]`);
                if (deleteBtn) {
                    targetRow = row;
                }
            });

            if (targetRow) {
                // Store original content
                const originalContent = targetRow.innerHTML;

                // Create progress UI
                targetRow.innerHTML = `
                    <td colspan="6">
                        <div class="delete-progress-multi">
                            <div class="phase-item pending" data-phase="Starting">
                                <span class="phase-icon"></span>
                                <span class="phase-label">Starting</span>
                            </div>
                            <div class="phase-item pending" data-phase="Counting">
                                <span class="phase-icon"></span>
                                <span class="phase-label">Counting</span>
                            </div>
                            <div class="phase-item pending" data-phase="Deleting">
                                <span class="phase-icon"></span>
                                <span class="phase-label">Deleting</span>
                            </div>
                            <div class="phase-item pending" data-phase="Updating">
                                <span class="phase-icon"></span>
                                <span class="phase-label">Updating</span>
                            </div>
                            <div class="phase-item pending" data-phase="Complete">
                                <span class="phase-icon"></span>
                                <span class="phase-label">Complete</span>
                            </div>
                        </div>
                    </td>
                `;

                // Listen for delete progress events
                if (deleteProgressListener) {
                    deleteProgressListener();
                }

                deleteProgressListener = await window.__TAURI__.event.listen('delete-progress', (event) => {
                    const progress = event.payload;
                    const phaseItems = targetRow.querySelectorAll('.phase-item');

                    phaseItems.forEach(item => {
                        const phaseName = item.getAttribute('data-phase');
                        const icon = item.querySelector('.phase-icon');
                        const label = item.querySelector('.phase-label');

                        if (phaseName === progress.phase) {
                            icon.textContent = '‚úì';
                            item.classList.remove('pending', 'completed');
                            item.classList.add('in-progress');

                            // Update label with message if it's the deletion phase
                            if (progress.phase === 'Deleting' && progress.message) {
                                label.textContent = progress.message;
                            }
                        } else {
                            // Check if this phase is before the current phase
                            const currentPhaseIndex = Array.from(phaseItems).findIndex(p => p.getAttribute('data-phase') === progress.phase);
                            const thisPhaseIndex = Array.from(phaseItems).indexOf(item);

                            if (thisPhaseIndex < currentPhaseIndex) {
                                icon.textContent = '‚úì';
                                item.classList.remove('pending', 'in-progress');
                                item.classList.add('completed');
                            }
                        }
                    });
                });

                try {
                    const result = await invoke('delete_terminology_data', { terminologyType });

                    // Clean up listener
                    if (deleteProgressListener) {
                        deleteProgressListener();
                        deleteProgressListener = null;
                    }

                    log(`‚úì ${result}`, 'success');
                    await refreshStorageInfo();
                    await refreshStatus();
                } catch (error) {
                    // Clean up listener
                    if (deleteProgressListener) {
                        deleteProgressListener();
                        deleteProgressListener = null;
                    }

                    // Restore original content on error
                    targetRow.innerHTML = originalContent;
                    log(`‚úó Failed to delete data: ${error}`, 'error');
                }
            } else {
                // Fallback if row not found
                try {
                    const result = await invoke('delete_terminology_data', { terminologyType });
                    log(`‚úì ${result}`, 'success');
                    await refreshStorageInfo();
                    await refreshStatus();
                } catch (error) {
                    log(`‚úó Failed to delete data: ${error}`, 'error');
                }
            }
        }

        async function deleteAll(terminologyType) {
            console.log('deleteAll called with:', terminologyType);
            const termName = getTerminologyDisplayName(terminologyType);

            const confirmed = await showConfirmDialog(
                'Confirm Complete Deletion',
                `Delete EVERYTHING for ${termName}?\n\nThis will remove:\n- Downloaded file\n- All database records\n\nYou'll need to re-download and re-import to use this terminology again.\n\nAre you sure?`
            );

            if (!confirmed) {
                console.log('User cancelled deletion');
                return;
            }
            console.log('User confirmed deletion, proceeding...');

            // Find the row in the storage table
            const tbody = document.getElementById('storageTableBody');
            const rows = tbody.querySelectorAll('tr');
            let targetRow = null;

            rows.forEach(row => {
                const deleteBtn = row.querySelector(`[data-type="${terminologyType}"]`);
                if (deleteBtn) {
                    targetRow = row;
                }
            });

            if (targetRow) {
                // Store original content
                const originalContent = targetRow.innerHTML;

                // Create progress UI (includes file deletion phase)
                targetRow.innerHTML = `
                    <td colspan="6">
                        <div class="delete-progress-multi">
                            <div class="phase-item pending" data-phase="Starting">
                                <span class="phase-icon"></span>
                                <span class="phase-label">Starting</span>
                            </div>
                            <div class="phase-item pending" data-phase="Counting">
                                <span class="phase-icon"></span>
                                <span class="phase-label">Counting</span>
                            </div>
                            <div class="phase-item pending" data-phase="Deleting">
                                <span class="phase-icon"></span>
                                <span class="phase-label">Deleting Data</span>
                            </div>
                            <div class="phase-item pending" data-phase="Updating">
                                <span class="phase-icon"></span>
                                <span class="phase-label">Updating</span>
                            </div>
                            <div class="phase-item pending" data-phase="Complete">
                                <span class="phase-icon"></span>
                                <span class="phase-label">Complete</span>
                            </div>
                        </div>
                    </td>
                `;

                // Listen for delete progress events
                if (deleteProgressListener) {
                    deleteProgressListener();
                }

                deleteProgressListener = await window.__TAURI__.event.listen('delete-progress', (event) => {
                    const progress = event.payload;
                    const phaseItems = targetRow.querySelectorAll('.phase-item');

                    phaseItems.forEach(item => {
                        const phaseName = item.getAttribute('data-phase');
                        const icon = item.querySelector('.phase-icon');
                        const label = item.querySelector('.phase-label');

                        if (phaseName === progress.phase) {
                            icon.textContent = '‚úì';
                            item.classList.remove('pending', 'completed');
                            item.classList.add('in-progress');

                            // Update label with message if it's the deletion phase
                            if (progress.phase === 'Deleting' && progress.message) {
                                label.textContent = progress.message;
                            }
                        } else {
                            // Check if this phase is before the current phase
                            const currentPhaseIndex = Array.from(phaseItems).findIndex(p => p.getAttribute('data-phase') === progress.phase);
                            const thisPhaseIndex = Array.from(phaseItems).indexOf(item);

                            if (thisPhaseIndex < currentPhaseIndex) {
                                icon.textContent = '‚úì';
                                item.classList.remove('pending', 'in-progress');
                                item.classList.add('completed');
                            }
                        }
                    });
                });

                try {
                    const result = await invoke('delete_all_terminology_data', { terminologyType });

                    // Clean up listener
                    if (deleteProgressListener) {
                        deleteProgressListener();
                        deleteProgressListener = null;
                    }

                    log(`‚úì ${result}`, 'success');
                    await refreshStorageInfo();
                    await refreshStatus();
                } catch (error) {
                    // Clean up listener
                    if (deleteProgressListener) {
                        deleteProgressListener();
                        deleteProgressListener = null;
                    }

                    // Restore original content on error
                    targetRow.innerHTML = originalContent;
                    log(`‚úó Failed to delete: ${error}`, 'error');
                }
            } else {
                // Fallback if row not found
                try {
                    const result = await invoke('delete_all_terminology_data', { terminologyType });
                    log(`‚úì ${result}`, 'success');
                    await refreshStorageInfo();
                    await refreshStatus();
                } catch (error) {
                    log(`‚úó Failed to delete: ${error}`, 'error');
                }
            }
        }

        let allValueSets = [];

        async function loadValueSets() {
            const btn = document.getElementById('loadValueSetsBtn');
            btn.disabled = true;
            btn.textContent = 'Loading...';

            try {
                const valuesets = await invoke('list_valuesets');
                allValueSets = valuesets;

                renderValueSetList(valuesets);
                document.getElementById('valuesetList').classList.remove('hidden');

                log(`Loaded ${valuesets.length} ValueSets`, 'success');
            } catch (error) {
                log(`‚úó Failed to load ValueSets: ${error}`, 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = 'Reload ValueSets';
            }
        }

        function renderValueSetList(valuesets) {
            const container = document.getElementById('valuesetList');

            if (valuesets.length === 0) {
                container.innerHTML = '<p class="no-results">No ValueSets available. Import ValueSets terminology first.</p>';
                return;
            }

            const html = `
                <table class="valueset-table">
                    <thead>
                        <tr>
                            <th>Title</th>
                            <th>URL</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${valuesets.map(([url, title]) => `
                            <tr>
                                <td>${title || url.split('/').pop()}</td>
                                <td><code class="valueset-url">${url}</code></td>
                                <td><button class="expand-btn" data-url="${url}">Expand</button></td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;

            container.innerHTML = html;

            // Add event listeners to expand buttons
            container.querySelectorAll('.expand-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const url = btn.getAttribute('data-url');
                    expandValueSet(url);
                });
            });
        }

        async function expandValueSet(url) {
            const expansionDiv = document.getElementById('valuesetExpansion');
            const titleEl = document.getElementById('expansionTitle');
            const contentEl = document.getElementById('expansionContent');

            titleEl.textContent = 'Loading...';
            contentEl.innerHTML = '<p class="loading-text">Expanding ValueSet...</p>';
            expansionDiv.classList.remove('hidden');

            log(`Expanding ValueSet: ${url}`);

            try {
                const expansion = await invoke('expand_valueset', { valuesetUrl: url });

                if (!expansion) {
                    contentEl.innerHTML = '<p class="no-results">ValueSet not found or has no expansion.</p>';
                    titleEl.textContent = 'Not Found';
                    return;
                }

                titleEl.textContent = expansion.title || url.split('/').pop();

                const html = `
                    <div class="expansion-meta">
                        <div class="meta-row">
                            <span class="meta-label">URL:</span>
                            <span class="meta-value"><code>${expansion.url}</code></span>
                        </div>
                        ${expansion.version ? `
                        <div class="meta-row">
                            <span class="meta-label">Version:</span>
                            <span class="meta-value">${expansion.version}</span>
                        </div>
                        ` : ''}
                        <div class="meta-row">
                            <span class="meta-label">Total Concepts:</span>
                            <span class="meta-value">${expansion.total}</span>
                        </div>
                    </div>
                    <table class="expansion-table">
                        <thead>
                            <tr>
                                <th>Code</th>
                                <th>System</th>
                                <th>Display</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${expansion.concepts.map(c => `
                                <tr>
                                    <td><code>${c.code}</code></td>
                                    <td>${c.system.split('/').pop()}</td>
                                    <td>${c.display || '-'}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;

                contentEl.innerHTML = html;
                log(`‚úì Expanded ValueSet with ${expansion.total} concepts`, 'success');
            } catch (error) {
                contentEl.innerHTML = `<p class="error-text">Failed to expand: ${error}</p>`;
                log(`‚úó Failed to expand ValueSet: ${error}`, 'error');
            }
        }

        function filterValueSets() {
            const input = document.getElementById('valuesetFilterInput');
            const filter = input.value.toLowerCase();

            if (!filter) {
                renderValueSetList(allValueSets);
                return;
            }

            const filtered = allValueSets.filter(([url, title]) => {
                return url.toLowerCase().includes(filter) || (title && title.toLowerCase().includes(filter));
            });

            renderValueSetList(filtered);
        }

        async function refreshStatus() {
            try {
                const allLatest = await invoke('get_all_local_latest');

                statusData = {};
                for (const version of allLatest) {
                    statusData[version.terminology_type] = version;
                }

                renderTerminologies();
            } catch (error) {
                log(`Failed to refresh status: ${error}`, 'error');
            }
        }

        function renderTerminologies() {
            const container = document.getElementById('terminologies');
            container.innerHTML = '';

            for (const term of terminologies) {
                const status = statusData[term.id];
                const card = document.createElement('div');
                card.className = 'terminology-card';
                card.setAttribute('data-id', term.id);

                // Handle unavailable terminologies
                if (!term.available) {
                    card.innerHTML = `
                        <h3>${term.name}</h3>
                        <span class="status not-synced">Not Available</span>
                        <p class="description">${term.description}</p>
                        <div class="card-actions">
                            <button class="sync-btn" disabled>
                                Not Available
                            </button>
                        </div>
                    `;
                    container.appendChild(card);
                    continue;
                }

                // Determine status badges
                // Only show "Downloaded" if we have both downloaded_at timestamp AND a valid file_path
                const downloaded = status && status.downloaded_at && status.file_path;
                const imported = status && status.imported;

                let statusBadges = '';
                if (downloaded) {
                    statusBadges += '<span class="status synced">Downloaded</span>';
                }
                if (imported) {
                    statusBadges += '<span class="status imported">Imported</span>';
                }
                if (!downloaded && !imported) {
                    statusBadges = '<span class="status not-synced">Not Synced</span>';
                }

                card.innerHTML = `
                    <h3>${term.name}</h3>
                    <div class="status-badges">${statusBadges}</div>
                    <p class="description">${term.description}</p>
                    ${(status && (downloaded || imported)) ? `
                        <div class="info-row">
                            <span class="info-label">Version:</span>
                            <span class="info-value">${status.version}</span>
                        </div>
                        ${downloaded ? `
                        <div class="info-row">
                            <span class="info-label">Downloaded:</span>
                            <span class="info-value">${new Date(status.downloaded_at).toLocaleDateString()}</span>
                        </div>
                        ` : ''}
                        ${status.imported && status.imported_at ? `
                        <div class="info-row">
                            <span class="info-label">Imported:</span>
                            <span class="info-value">${new Date(status.imported_at).toLocaleDateString()}</span>
                        </div>
                        ` : ''}
                        ${status.effective_date ? `
                        <div class="info-row">
                            <span class="info-label">Effective Date:</span>
                            <span class="info-value">${status.effective_date}</span>
                        </div>
                        ` : ''}
                    ` : '<p class="no-version">No local version available</p>'}
                    <div class="card-actions">
                        <button class="sync-btn" data-term-id="${term.id}">
                            Sync Latest
                        </button>
                        ${downloaded && !imported ? `
                        <button class="import-btn" data-term-id="${term.id}">
                            Import Data
                        </button>
                        ` : ''}
                    </div>
                `;

                container.appendChild(card);
            }

            // Add event listeners to sync buttons
            const syncButtons = document.querySelectorAll('.sync-btn[data-term-id]');
            syncButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const termId = button.getAttribute('data-term-id');
                    syncTerminology(termId);
                });
            });

            // Add event listeners to import buttons
            const importButtons = document.querySelectorAll('.import-btn[data-term-id]');
            importButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const termId = button.getAttribute('data-term-id');
                    importTerminology(termId);
                });
            });
        }

        async function cleanupGhostVersions() {
            const btn = document.getElementById('cleanupGhosts');
            btn.disabled = true;
            btn.textContent = 'Cleaning...';

            try {
                const result = await invoke('cleanup_ghost_versions');
                log(`‚úì ${result}`, 'success');
                await refreshStatus();
                await refreshStorageInfo();
            } catch (error) {
                log(`‚úó Cleanup failed: ${error}`, 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = 'Cleanup Database';
            }
        }

        async function testConnection() {
            const btn = document.getElementById('testConnection');
            const statusDiv = document.getElementById('connectionStatus');

            btn.disabled = true;
            btn.textContent = 'Testing...';
            statusDiv.classList.add('hidden');

            try {
                const status = await invoke('test_connection');

                statusDiv.className = status.connected ? 'connection-status success' : 'connection-status error';
                statusDiv.innerHTML = `
                    <strong>${status.connected ? '‚úì Connected' : '‚úó Connection Failed'}</strong>
                    <p>${status.message}</p>
                    ${!status.connected ? `
                        <ul class="error-details">
                            <li>Authentication: ${status.auth_ok ? '‚úì OK' : '‚úó Failed'}</li>
                            <li>Feed Access: ${status.feed_ok ? '‚úì OK' : '‚úó Failed'}</li>
                        </ul>
                        <p class="error-hint">
                            ${!status.auth_ok ? 'Check your NCTS_CLIENT_ID and NCTS_CLIENT_SECRET in .env file' : 'NCTS API may be temporarily unavailable'}
                        </p>
                    ` : ''}
                `;
                statusDiv.classList.remove('hidden');

                log(status.connected ? '‚úì NCTS connection successful' : `‚úó Connection failed: ${status.message}`,
                    status.connected ? 'success' : 'error');
            } catch (error) {
                statusDiv.className = 'connection-status error';
                statusDiv.innerHTML = `
                    <strong>‚úó Connection Test Failed</strong>
                    <p>${error}</p>
                    <p class="error-hint">Ensure you have NCTS credentials configured in your .env file</p>
                `;
                statusDiv.classList.remove('hidden');
                log(`‚úó Connection test error: ${error}`, 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = 'Test NCTS Connection';
            }
        }

        async function showAmtStats() {
            const modal = document.getElementById('amtStatsModal');
            const content = document.getElementById('amtStatsContent');

            modal.classList.remove('hidden');
            content.innerHTML = '<p>Loading AMT code type statistics...</p>';

            try {
                const stats = await invoke('get_amt_code_type_stats');

                if (stats.length === 0) {
                    content.innerHTML = '<p class="no-results">No AMT codes found. Please import AMT terminology first.</p>';
                    return;
                }

                const totalCodes = stats.reduce((sum, stat) => sum + stat.count, 0);

                let html = `<p class="stats-total">Total AMT Codes: <strong>${totalCodes.toLocaleString()}</strong></p>`;
                html += '<table class="stats-table">';
                html += '<thead><tr><th>Code Type</th><th>Count</th><th>Percentage</th><th>Description</th></tr></thead>';
                html += '<tbody>';

                const descriptions = {
                    'CTPP': 'Containered Trade Product Pack (e.g., Panadol 500mg tablet, blister pack, 20)',
                    'TPP': 'Trade Product Pack (e.g., Panadol 500mg tablet, 20)',
                    'TPUU': 'Trade Product Unit of Use (e.g., Panadol 500mg tablet)',
                    'TP': 'Trade Product (e.g., Panadol)',
                    'MPP': 'Medicinal Product Pack (e.g., Paracetamol 500mg tablet, 20)',
                    'MPUU': 'Medicinal Product Unit of Use (e.g., Paracetamol 500mg tablet)',
                    'MP': 'Medicinal Product (e.g., Paracetamol)',
                };

                stats.forEach(stat => {
                    const percentage = ((stat.count / totalCodes) * 100).toFixed(1);
                    const isPatientCode = stat.code_type === 'MP' || stat.code_type === 'TP';
                    const rowClass = isPatientCode ? 'patient-code-row' : '';
                    html += `<tr class="${rowClass}">
                        <td><strong>${stat.code_type}</strong>${isPatientCode ? ' üîπ' : ''}</td>
                        <td>${stat.count.toLocaleString()}</td>
                        <td>${percentage}%</td>
                        <td class="description">${descriptions[stat.code_type] || ''}</td>
                    </tr>`;
                });

                html += '</tbody></table>';
                html += '<p class="stats-note">üîπ = Available in Patient search mode</p>';

                content.innerHTML = html;
                log('‚úì AMT code type statistics loaded');
            } catch (error) {
                content.innerHTML = `<p class="error-message">Failed to load statistics: ${error}</p>`;
                log(`‚úó Failed to load AMT stats: ${error}`, 'error');
            }
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', async () => {
            log('Application started');

            // Add event listeners to top-level buttons
            document.getElementById('testConnection').addEventListener('click', testConnection);
            document.getElementById('syncAll').addEventListener('click', syncAll);
            document.getElementById('refreshStatus').addEventListener('click', refreshStatus);
            document.getElementById('cleanupGhosts').addEventListener('click', cleanupGhostVersions);
            document.getElementById('searchBtn').addEventListener('click', searchTerminology);

            // AMT stats button event listener
            document.getElementById('showAmtStatsBtn').addEventListener('click', showAmtStats);
            document.querySelector('#amtStatsModal .close-modal').addEventListener('click', () => {
                document.getElementById('amtStatsModal').classList.add('hidden');
            });

            // ValueSet browser event listeners
            document.getElementById('loadValueSetsBtn').addEventListener('click', loadValueSets);
            document.getElementById('valuesetFilterInput').addEventListener('input', filterValueSets);
            document.getElementById('closeExpansionBtn').addEventListener('click', () => {
                document.getElementById('valuesetExpansion').classList.add('hidden');
            });

            // Allow search on Enter key
            document.getElementById('searchInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    searchTerminology();
                }
            });

            // Event delegation for storage management delete buttons
            document.getElementById('storageTableBody').addEventListener('click', (e) => {
                console.log('Click detected on storage table');
                console.log('Click target:', e.target);
                console.log('Target tagName:', e.target.tagName);
                console.log('Target classes:', e.target.className);

                const button = e.target.closest('button');
                console.log('Found button:', button);

                if (!button) {
                    console.log('No button found, returning');
                    return;
                }

                console.log('Button classes:', button.className);
                console.log('Button data-type:', button.dataset.type);

                if (button.classList.contains('delete-file')) {
                    console.log('Calling deleteFile for:', button.dataset.type);
                    deleteFile(button.dataset.type);
                } else if (button.classList.contains('delete-data')) {
                    console.log('Calling deleteData for:', button.dataset.type);
                    deleteData(button.dataset.type);
                } else if (button.classList.contains('delete-all')) {
                    console.log('Calling deleteAll for:', button.dataset.type);
                    deleteAll(button.dataset.type);
                } else {
                    console.log('Button found but no matching class');
                }
            });

            await refreshStatus();
            await refreshStorageInfo();
        });
    </script>
</body>
</html>
